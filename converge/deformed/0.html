<!DOCTYPE html>
<html lang="en">
<head>
  <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1" />
  <link rel="stylesheet" media="screen" href="../screen.css" />
  <link rel="stylesheet" media="print" href="../print.css" />
  <title>Deformed algebras</title>
  <link rel="icon" href="/images/mike.ico" type="image/ico" sizes="16x16">
  <script src="https://polyfill.io/v3/polyfill.min.js?features=es6"></script>
  <script id="MathJax-script" async src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-chtml.js"></script>
  <style type="text/css">
    .shrink {font-size:0.95em}
  </style>
</head>
<body>
  <header>C<span class="shrink">o<span class="shrink">n<span class="shrink">v<span class="shrink">e<span class="shrink">r<span class="shrink">g<span class="shrink">e<span class="shrink">n<span class="shrink">c<span class="shrink">e</span></span></span></span></span></span></span></span></span></span></header>
  <script src="../nav.js"></script>
<div id="prev" class="pointer"><a>◀ Previous</a></div>
<article>
<h1 id="deformed-algebras">Deformed algebras</h1>
<h2 id="creation-and-annihilation">Creation and annihilation</h2>
<p>We start from the standard creation and annihilation operators, and a hermitean (self-adjoint) number operator:</p>
<p><span class="math display">\[[N,a^\dagger]=a^\dagger,[N,a]=-a\]</span></p>
<p>Given a state <span class="math inline">\(N|n\rangle=n|n\rangle\)</span>, we can generate states <span class="math inline">\(|n+1\rangle\propto a^\dagger|n\rangle\)</span> and <span class="math inline">\(|n-1\rangle\propto a|n\rangle\)</span>. This follows from the commutation relations:</p>
<p><span class="math display">\[Na^\dagger|n\rangle=(a^\dagger N+a^\dagger)|n\rangle=(n+1)a^\dagger|n\rangle\]</span></p>
<p>and the analogous calculation for <span class="math inline">\(a\)</span>. This only breaks down if <span class="math inline">\(a^\dagger|n\rangle=0\)</span> or <span class="math inline">\(a|n\rangle=0\)</span>. Such states, if they exist, are the maximum and minimum weight states, respectively. We are, of course, mapping this structure on our understanding of quantum mechanics, but presumably the ideas (not my own) could be of more general use.</p>
<p>We assume that all self-adjoint operators that commute with <span class="math inline">\(N\)</span> are functions of <span class="math inline">\(N\)</span>; i.e., it is a complete set of commuting observables in itself, and if a state <span class="math inline">\(|n\rangle\)</span> exists, it is non-degenerate.</p>
<p>We will generally assume that the <span class="math inline">\(N\)</span>-spectrum is discrete. We can therefore decompose (with unit vectors <span class="math inline">\(\langle n | n\rangle=1\)</span>):</p>
<p><span class="math display">\[N=\sum n|n\rangle\langle n|\]</span></p>
<p>We also assume that <span class="math inline">\(a,a^\dagger\)</span> are adjoints of each other.</p>
<p>If a self-adjoint operator <span class="math inline">\(S^\dagger=S\)</span> commutes with <span class="math inline">\(N\)</span>:</p>
<p><span class="math display">\[NS|n\rangle=SN|n\rangle=nS|n\rangle.\]</span></p>
<p>This means that <span class="math inline">\(S|n\rangle\)</span> is an eigenstate of <span class="math inline">\(N\)</span> with <span class="math inline">\(n\)</span> eigenvalue and hence <span class="math inline">\(S|n\rangle=s(n)|n\rangle\)</span>, since N has non-degenerate eigenstates (i.e. there at most one for <em>any</em> possible eigenvalue). Therefore:</p>
<p><span class="math display">\[S=\sum s(n)|n\rangle\langle n|=s(N)\]</span></p>
<p>The self-adjoint combinations <span class="math inline">\(aa^\dagger\)</span> and <span class="math inline">\(a^\dagger a\)</span> commute with <span class="math inline">\(N\)</span>, hence:</p>
<p><span class="math display">\[aa^\dagger=\Psi(N),a^\dagger a=\Phi(N)\]</span></p>
<p>For a discrete state <span class="math inline">\(|n\rangle\)</span>, remembering that <span class="math inline">\(a^\dagger|n\rangle\propto|n+1\rangle\)</span>:</p>
<p><span class="math display">\[a^\dagger aa^\dagger|n\rangle=\Phi(n+1)a^\dagger|n\rangle=\Psi(n)a^\dagger|n\rangle\]</span></p>
<p>So we have:</p>
<p><span class="math display">\[aa^\dagger=\Phi(N+1),a^\dagger a=\Phi(N)\]</span></p>
<p>We have that <span class="math inline">\(\Phi\)</span> is positive for all “physical” values of <span class="math inline">\(n\)</span>, since <span class="math inline">\(a,a^\dagger\)</span> are mutual adjoints:</p>
<p><span class="math display">\[\langle n|a^\dagger a|n\rangle=\langle an|an\rangle\ge0\]</span></p>
<p>where we have abbreviated <span class="math inline">\(a|n\rangle=|an\rangle\)</span> to make things hopefully clearer. The point is that for a Born probability interpretation to work we need the states to have positive (square) norm.</p>
<p>The function <span class="math inline">\(\Phi\)</span> allow us to find the normalizations for <span class="math inline">\(a,a^\dagger\)</span>:</p>
<p><span class="math display">\[a|n\rangle=\sqrt{\Phi(n)}|n-1\rangle\]</span></p>
<p>up to a phase. Similarly:</p>
<p><span class="math display">\[a^\dagger|n\rangle=\sqrt{\Phi(n+1)}|n+1\rangle\]</span></p>
</article><div  id="next" class="pointer"><a class="pointright">Next ▶</a></div>
  <script src="/js/footer.js"></script>
<script src="../number.js"></script>
</body>
</html>